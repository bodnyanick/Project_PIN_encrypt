#include "pin_encrypt.h"

// 1 2 3 A
// 4 5 6 B
// 7 8 9 C
// D 0 E F

// ABCD - [1010] [1011] [1100] [1101]
//          0      1      2      3

// DBAC   [1101] [1011] [1010] [1100]
//           3      1      0     2

// 4 bytes - 2 bytes = 2 bytes
// input = 2 bytes - pwd
// output = 4 bytes - encrypted pwd

// [A] [B] [C] [D]
// [00][01][10][11]
// [00011011] - индексы [order]

//? ВАРИАНТ №1
//  [D]     [B]    [A]    [C] - pwd
//  [3]     [1]    [0]    [2]
//! так выглядит информация после перемешивания букв
// [1101] [1011] [1010] [1100] - 2 bytes [pwd] (пароль)
//! кодирование по алгоритму индексов
//  [11]   [01]   [00]   [10] - order (индексы)
//! так информация будет храиться в битах после зашифровки
// [11010010] - 1 bytes [order] (индексы)
//!  1 байт    1    1   1 байт
//! [order?] [DB] [AC] [order?] - так в памяти будет храниться пин (ABCD) и индекс (order). А так же случайный набор байтов вместо одного из ордеров

//? ВАРИАНТ №2
//  [A]     [D]    [C]    [B] - pwd
//  [0]     [3]    [2]    [1] - order
//! так выглядит информация после перемешивания букв в битах
// [1010] [1101] [1100] [1011] - 2 bytes [pwd] (пароль)
// [00111001] - 1 bytes [order] (индексы)



// ТЕПЕРЬ ПРИМЕР ВХОДА-ВЫХОДА В БАЙТАХ С УЧЁТОМ ИНДЕКСОВ И СЛУЧАЙНОГО НАБОРА
//? ВАРИАНТ №1
//!             password            A      B      C      D
// input = [1010101111001101] ИЛИ [1010] [1011] [1100] [1101]
//!         [  order ] [    password    ] ИЛИ   D      B      A      C    [  error ]
// output = [11010010] [1101101110101100] ИЛИ [1101] [1011] [1010] [1100] [10111001]
//? ВАРИАНТ №2
//!             password            A      B      C      D
// input = [1010101111001101] ИЛИ [1010] [1011] [1100] [1101]
//!         [  error ] [    password    ] ИЛИ   A      D      C      B    [  order ]
// output = [11000000] [1010110111001011] ИЛИ [1010] [1101] [1100] [1011] [00111001]

// A   B   C   D
// 0   1   2   3
// 00  01  10  11 = 00011011

// D   B   A   C
// 3   1   0   2
// 11  01  00  10 = 11010010

// 11000000 - D
// |
// 00010000 - B
// |
// 00000000 - A
// |
// 00000010 - C
// =
// 11010010

//!D
//    00000011
// << 6
// =  11000000
//!B
//    00000001
// << 4
// =  00010000
//!A
//    00000000
// << 2
// =  00000000
//!C
//    00000010
// << 0
// =  00000010





uint_32 encrypt (ubyte a1, ubyte a2 , ubyte a3, ubyte a4);
{
    uint_32 result = 0;
    return result;
}

